
## Java: 前期绑定和后期绑定



对于面向对象程序设计的最重要的妙诀：编译器不肯呢个产生传统意义上的函数调用。一个非面向对象的编译器产生的函数调用会引起所谓的**前期绑定**，这么做意味着编译器将产生对一个具体函数名字的调用，而运行时将这个调用解析到将要被执行的代码的绝对地址。然而在OOP中，程序直到**运行时**才能够确认代码的地址，所以当消息发送到一个泛化对象时，必须采用其他的机制。



为了解决这个问题，面向对象程序设计语言使用了**后期绑定** 的概念。当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查（无法提供此类保证的语言称为**弱类型**的 ），但是并不知道被执行的确切代码。



为了执行**后期绑定** ，Java使用一小段特殊的代码来代替绝对地址调用。这段代码使用在对象中存储的信息来计算方法体的地址。这样根据这一小段代码的内容，每个对象都可以具有不同的行为表现。当向一个对象发送消息的时候，该对象就能够知道对这个消息应该做些什么。



在某些语言中，必须明确地声明希望某个方法具备后期绑定属性所带来的灵活性（C++是使用virtual 关键字来实现的），在这些语言中，方法默认不是动态绑定的。而**在Java中，动态绑定是默认行为**  ，不需要添加额外的关键字来实现多态。



---java 编程思想



多态，算是一种计算机程序语言级别的设计模式设计思想，我以前只觉得设计模式会用在更高的层次上，没想到在语言的原子级别居然也有这么漂亮的设计模式的思想。



再者对于运行时的理解，以前我对于运行时的理解是基于OS的。因为操作系统中涉及到的汇编->链接->装入的过程中理解过运行时。因为运行时动态链接是对于虚拟段页式内存管理的基础。（**运行时动态链接** 对某些目标模块的链接在程序执行过程中需要目标模块时，才对其进行链接）。Java的多态的动态绑定，是对运行时的十分典型的诠释。之前对于运行时的理解仅仅停留在了对在装入过程中，何时进行链接所需模块到内存这种层次，没有细致考虑具体实例是什么样的过程，看到这个叙述，感觉有所收获





:)





by wanglinzhizhi
